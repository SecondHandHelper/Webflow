<!-- The core Firebase JS SDK is always required and must be listed first -->
<script src="https://www.gstatic.com/firebasejs/8.3.1/firebase-app.js"></script>

<!-- TODO: Add SDKs for Firebase products that you want to use
     https://firebase.google.com/docs/web/setup#available-libraries -->
<script src="https://www.gstatic.com/firebasejs/8.3.1/firebase-analytics.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.3.1/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.3.1/firebase-firestore.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.3.1/firebase-functions.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.3.1/firebase-storage.js"></script>
<script src="https://rawcdn.githack.com/SecondHandHelper/Webflow/v1.0.36/general.js"></script>
<script src="https://rawcdn.githack.com/SecondHandHelper/Webflow/v1.0.30/infoRequestsFunctions.js"></script>
<script src="https://rawcdn.githack.com/SecondHandHelper/Webflow/v1.0.32/referralFunctions.js"></script>
<script src="https://rawcdn.githack.com/SecondHandHelper/Webflow/v1.0.34/cookieManagement.js"></script>
<script src="https://rawcdn.githack.com/SecondHandHelper/Webflow/v1.0.1/autocomplete-brands.js"></script>
<script src="https://rawcdn.githack.com/SecondHandHelper/Webflow/test31/onPageLoad.js"></script>
<script src="https://rawcdn.githack.com/SecondHandHelper/Webflow/test32/loadCardLists.js"></script>

<script>
  // Firebase config
  var firebaseConfig = {
    apiKey: "AIzaSyCMWv3TzZuGPDg41K8wa_PY10rgtitoCnA",
    authDomain: "second-hand-helper.firebaseapp.com",
    projectId: "second-hand-helper",
    storageBucket: "second-hand-helper.appspot.com",
    messagingSenderId: "886292162262",
    appId: "1:886292162262:web:a5679ec376bdec00600b77",
    measurementId: "G-654T8V21EB"
  };
  // Initialize Firebase
  firebase.initializeApp(firebaseConfig);
  firebase.analytics();
  var db = firebase.firestore();
  var functions = firebase.functions();
  var storage = firebase.storage();
  var auth = firebase.auth();
</script>

<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KWV4J65" height="0" width="0"
    style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->

<script>
  // GET USER
  var user;
  var authUser;
  firebase.auth().onAuthStateChanged((result) => {
    const now = new Date().toISOString();

    if (result) {
      authUser = result;

      // Get and set currentUser
      db.collection("users").doc(authUser.uid).get().then((doc) => {
        if (doc.exists) {
          user = doc.data();
          console.log("user:", user);
          console.log("authUser", authUser);

          // FB Pixel
          fbq('init', '681886049842735', { 'external_id': authUser.uid }); fbq('track', 'PageView');

          // Own Attribution (Will be removed)
          tryAttribution();

          let createdAt = new Date(authUser.metadata.creationTime).toISOString();
          let latestLogin = new Date(authUser.metadata.lastSignInTime).toISOString();

          // Segment
          const firstName = user.addressFirstName ? user.addressFirstName : null ;
          const lastName = user.addressLastName ? user.addressLastName : null ;
          const email = user.email ? user.email : null ;
          const phone = user.phoneNumber ? user.phoneNumber : null ;
          const street = user.addressStreetAddress ? user.addressStreetAddress : null ;
          const city = user.addressCity ? user.addressCity : null ;
          const postalCode = user.addressPostalCode ? user.addressPostalCode : null ;
          const doorCode = user.addressDoorCode ? user.addressDoorCode : null ;
          const replace = user.replace ? user.replace : null ;
          console.log("doorCode", doorCode);
    
          analytics.identify(`${authUser.uid}`, { 
            createdAt,
            firstName,
            lastName,
            email,
            phone,
            address: {
              street,
              city,
              postalCode,
              doorCode
            },
            latestLogin,
            latestPageView: now
          });
        }

        if (typeof window.main === "function") {
          main();
        }
      }).catch((error) => { console.log("Error getting document:", error); });
    } else {
      analytics.identify({
        latestPageView: now
      });
      console.log('No user');
    }
  });
</script>
<script>
  // FUNCTIONS PRIVATE PAGE
  function formatPhoneNumber(str) {
    if (str.slice(0, 1) == 0 && str.length == 10) {
      str = str.substring(1);
      str = "+46" + str;
    }
    if (str.slice(0, 1) == 7 && str.length == 9) {
      str = "+46" + str;
    }
    return str;
  }

  // FUNCTIONS - SELL ITEM
  async function addItem() {
    let sex = "";
    let pricing = "";
    const now = new Date();
    let status = "New";
    let shippingStatus = "Not sent";
    const size = itemSize.value;
    const material = itemMaterial.value;
    const brand = itemBrand.value;
    const model = itemModel.value;
    const originalPrice = Number(itemOriginalPrice.value);
    const age = itemAge.value;

    const condition = itemCondition.value;
    const defectDescription = itemDefectDescription.value;
    const noAnimals = itemNoAnimals.checked;
    const noSmoke = itemNoSmoke.checked;
    const userComment = itemUserComment.value;
    let happyPrice = Number(itemHappyPrice.value);
    let acceptPrice = Number(itemAcceptPrice.value);
    const lowestAcceptPrice = Number(itemLowestAcceptPrice.value);
    const phoneNumber = itemPhoneNumber.value;

    let defectElements = new Map().set("hole", hole.checked).set("stain", stain.checked).set("lostFit", lostFit.checked).set("nopprig", nopprig.checked).set("threadUp", threadUp.checked).set("colorChange", colorChange.checked).set("otherDefect", otherDefect.checked);
    let defectsChoicesInSwedish = new Map().set("hole", "Hål").set("stain", "Fläck").set("lostFit", "Tappad passform").set("nopprig", "Nopprig").set("threadUp", "Trådsläpp").set("colorChange", "Färgändring").set("otherDefect", "Annat");
    let defects = [];

    defectElements.forEach(async (value, key) => {
      if (value == true) {
        let string = defectsChoicesInSwedish.get(key);
        defects.push(string);
      }
    });

    // Get radio buttons
    var sexRadioButtons = document.getElementsByName("Sex");
    for (var x = 0; x < sexRadioButtons.length; x++) {
      if (sexRadioButtons[x].checked) {
        sex = sexRadioButtons[x].id;
      }
    }

    // Get who sets price
    var pricingRadioButtons = document.getElementsByName("Pricing");
    for (var x = 0; x < pricingRadioButtons.length; x++) {
      if (pricingRadioButtons[x].checked) {
        pricing = pricingRadioButtons[x].id;
        if (pricing == "We set price") {
          acceptPrice = lowestAcceptPrice;
          happyPrice = 0;
        }
      }
    }

    // Add phone number to user document
    if (phoneNumber) {
      writePhoneNumberToFirestore(window.uid, phoneNumber);
    }

    // Create item in FS without the images first, to get the ItemID
    createItemInFirestore();

    async function createItemInFirestore() {
      var itemId = "";
      var imageUrls = {};
      imageUrls['frontImage'] = ""; // Part of the ugly hack

      const collectionRef = db.collection('items');

      // Writes to FS
      const res = await collectionRef.add({
        user: window.uid,
        createdAt: now,
        status: status,
        shippingStatus: shippingStatus,
        sex: sex,
        size: size,
        material: material,
        brand: brand,
        model: model,
        originalPrice: originalPrice,
        age: age,
        condition: condition,
        defects: defects,
        defectDescription: defectDescription,
        noAnimals: noAnimals,
        noSmoke: noSmoke,
        userComment: userComment,
        pricing: pricing,
        happyPrice: happyPrice,
        acceptPrice: acceptPrice,
        images: imageUrls // To compare the change after the images have been uploaded

      })
        .then((docRef) => {
          //window.itemId = docRef.id;
          itemId = docRef.id;
          console.log("Document written with ID: ", itemId);
          uploadImages(itemId);
        })
        .catch((error) => {
          console.error("Error adding document: ", error);
        });
    }

    async function uploadImages(itemId) {
      //Gather files from the form in a map "Images"
      let elements = ["frontImage", "brandTagImage", "productImage", "defectImage", "materialTagImage", "extraImage"];
      let images = new Map();
      let imageUrls = {};
      let imagePaths = {};

      elements.forEach(element => {
        if (document.getElementById(element).files[0]) {
          let file = document.getElementById(element).files[0];
          images.set(element, file);
        }
      });

      // Uploads files and gather URLs in an object "imagePaths"
      const storageRef = storage.ref();
      images.forEach(async (value, key) => {
        let imagePathReference = `images/${itemId}/${key}`;
        let fileRef = storageRef.child(imagePathReference);
        await fileRef.put(value);
        const imageDownloadUrl = await fileRef.getDownloadURL();
        imageUrls[key] = imageDownloadUrl;
        imagePaths[key] = imagePathReference;

        if (Object.keys(imagePaths).length == images.size) {
          writeImagePathToFirestore(itemId, imageUrls, imagePaths);
        }
      })
    }

    async function writeImagePathToFirestore(itemId, imageUrls, imagePaths) {
      // Check if seller has added address first
      var addressFirstName = "";
      var docRef = db.collection("users").doc(window.uid);
      await docRef.get().then((doc) => {
        if (doc.data().addressFirstName) {
          addressFirstName = doc.data().addressFirstName;
        }
      }).catch((error) => {
        console.log("Error getting document:", error);
      });

      // Set the imagePaths of the item
      const itemRef = db.collection('items').doc(itemId);
      const res = await itemRef.update({
        images: imageUrls,
        imageStoragePaths: imagePaths
      }).then(function () {
        console.log(`Images of ${itemId} updated`);

        if (addressFirstName == "") {
          addressFormDiv.style.display = 'block';
          addItemFormDiv.style.display = 'none';
        } else {
          window.location.href = window.location.origin + "/private";
        }
      });
    }
  }

  async function updateItem(itemId, changedImages) {
    const now = new Date();
    const size = itemSize.value;
    const material = itemMaterial.value;
    const brand = itemBrand.value;
    const model = itemModel.value;
    const originalPrice = Number(itemOriginalPrice.value);
    const age = itemAge.value;
    const condition = itemCondition.value;
    const defectDescription = itemDefectDescription.value;
    const userComment = itemUserComment.value;
    const lowestAcceptPrice = Number(itemLowestAcceptPrice.value);
    let changes = {
      updatedAt: now,
      size: size,
      material: material,
      brand: brand,
      model: model,
      originalPrice: originalPrice,
      age: age,
      condition: condition,
      defectDescription: defectDescription,
      userComment: userComment,
      acceptPrice: lowestAcceptPrice
    }

    async function uploadImages(itemId) {
      console.log("uploadImages()");
      if (changedImages.length > 0) {
        // START - Mark imageRequest as Resolved
        await db.collection("items").doc(itemId).get().then((doc) => {
          if (doc.data()?.infoRequests?.images?.status === "Active") {
            changes["infoRequests.images.status"] = "Resolved";
          }
        });
        // END - Mark imageRequest as Resolved
        let elements = changedImages;
        let images = new Map(); //Gather files from the form in a map "Images"
        elements.forEach(element => {
          if (document.getElementById(element).files[0]) {
            let file = document.getElementById(element).files[0];
            images.set(element, file);
          }
        });
        // Uploads files and add the new imageUrls to the changes object
        const storageRef = storage.ref();
        images.forEach(async (value, key) => {
          console.log(`${key}: ${value}`);
          // If images was changed, set photo directions to default, since an 'info request' of images could have been shown
          photoDirectionsText.style.display = 'block';
          infoRequestImagesDiv.style.display = 'none';

          let imagePathReference = `images/${itemId}/${key}`;
          let fileRef = storageRef.child(imagePathReference);
          await fileRef.put(value);
          const imageDownloadUrl = await fileRef.getDownloadURL();
          let k = "images." + key;
          changes[k] = imageDownloadUrl;
          if (key == "frontImage") {
            console.log("CHANGES SET!!!!!!");
            changes["images.frontImageSmall"] = "";
            changes["images.frontImageMedium"] = "";
            changes["images.frontImageLarge"] = "";
          }
          if (elements.length == images.size) {
            updateItemDoc(itemId, changes);
          }
        })
      } else {
        updateItemDoc(itemId, changes);
      }
    }

    async function updateItemDoc(itemId, changes) {
      console.log("updateItemDoc()");
      // Update item in FS without the images first, only because that's how I did it when adding an item.
      console.log("CHANGES: ", changes);
      const itemRef = db.collection('items').doc(itemId);
      const res = await itemRef.update(changes)
        .then((itemRef) => {
          console.log("Document updated with ID: ", itemId);
          saveChangesButtonText.style.color = "#7a7575";
          saveChangesButtonText.innerHTML = "Sparat";
        })
        .catch((error) => {
          console.error("Error adding document: ", error);
        });
    }

    uploadImages(itemId);
  }
</script>